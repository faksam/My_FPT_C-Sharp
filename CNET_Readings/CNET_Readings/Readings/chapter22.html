<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
<title>FPT University - C# & .NET technology</title>
<link rel="stylesheet" href="cf112.css" type="text/css" charset="utf-8" />
</head>
<body>
    <div align="center">
      <center>
    <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0; bordercolor: #111111" width="1024" id="AutoNumber6">
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; height:168px" height="2" bgcolor="#339966" bordercolor="#333333" background="images/background.jpg"><br /><br />
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0; text-align:center" ><br/>
        <b><font size="5" color="#FFFFFF" face="Arial Black">Software Development</font></b></p>
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0"><i>
        <font face="Arial Black" color="#FFCC00">&nbsp;</font></i><br/>
        <br/></p>&nbsp;</td>
      </tr>
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; bordercolor:#333333" bgcolor="#FFFFFF" valign="top">
        <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 0; border-right-width: 0; border-bottom-width:0" bordercolor="#006666" width="100%" id="AutoNumber7" height="8">
          <tr>
            <td width="12%" style="border-left: 1px solid #006666; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="index.html">Home</a></td>
            <td width="18%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="outline.html">Outline</a></td>
            <td width="26%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="timeline.html">Timeline</a></td>
            <td width="24%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="readings.html">Readings</a></td>
            <td width="20%" style="border-left-style: solid; border-left-width: 1; border-right: 1px solid #006666; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="instructors.html">Instructors</a></td>
          </tr>
          <tr>
            <td width="100%" style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: solid; border-top-width: 1; border-bottom-style: none; border-bottom-width: medium" align="center" colspan="5">
            <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0" bordercolor="#111111" width="100%" id="AutoNumber8">
              <tr>
                <td width="100%" style="border-style: none; border-width: medium">
                <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 2; border-right-width: 2; border-top-width: 2; border-bottom-width: 0" bordercolor="#006666" id="AutoNumber9" height="1">
                  <tr>
                    <td width="100%" style="border-style: none; border-width: medium" height="1" colspan="2" bgcolor="#004646">
                    <p style="margin-top: -6; margin-bottom: -6"/></td>
                  </tr>
                  <tr>
                    <td style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: none; border-top-width: medium; border-bottom: 2px none #006666" height="1" bgcolor="#006666" valign="top">
                    <div align="center" style="width: 169">
                      <center>
                      <p style="margin-top: -4; margin-bottom: -4">&nbsp;</p>
                      <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" width="91%" id="AutoNumber10" bgcolor="#FFFFFF" height="1" bordercolor="#003399">
                        <tr>
            <td width="100%" bgcolor="#CAD6EE" style="border-left-color: #003399; border-left-width: 2; border-right-color: #003399; border-right-width: 2; border-top-color:#003399; border-bottom-color:#003399" height="20">
            <p style="margin: 2 3"><b>
            <font face="Verdana" size="2" color="#003399">Readings</font></b></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-bottom-style: none; border-bottom-width: medium; border-top-style:solid; border-top-width:1" height="25">
            <p style="margin: 2 3; "><a class="leftmenu" href="Chapter01.html">Chapter 1</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter02.html">Chapter 2</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter03.html">Chapter 3</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter04.html">Chapter 4</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter05.html">Chapter 5</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter06.html">Chapter 6</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter07.html">Chapter 7</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter08.html">Chapter 8</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter10.html">Chapter 10</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter11.html">Chapter 11</a></p></td>
                        </tr>                        
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter13.html">Chapter 13</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter14.html">Chapter 14</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter16.html">Chapter 16</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter17.html">Chapter 17</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter19.html">Chapter 19</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter20.html">Chapter 20</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter21.html">Chapter 21</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter22.html">Chapter 22</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter23.html">Chapter 23</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter24.html">Chapter 24</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter25.html">Chapter 25</a></p></td>
                        </tr>
                      </table>
                      </center>
                    </div>
                    </td>                    
                    <td width="855" style="border-left-style: none; border-left-width: medium; border-right-style: solid; border-right-width: 1; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium" height="1" valign="top">
                    <div style="margin-left:10px;margin-top:10px;margin-bottom:10px;margin-right:10px">
                    <h1>Chapter 22 - Data access with ADO.NET</h1>
                    <span id="top" class="style1">Content</span>
                    <ul>
                    <li><a href="#int" class="leftmenu">Introduction to ADO.NET</a></li>                    
                    <li><a href="#pro" class="leftmenu">Understanding ADO.NET Data Providers</a></li>
                    <li><a href="#lay" class="leftmenu">Understanding the Connected Layer of ADO.NET</a></li>
                    <li><a href="#rea" class="leftmenu">Working with Data Readers</a></li>
                    <li><a href="#com" class="leftmenu">Modify tables using Command objects</a></li>
                    <li><a href="#par" class="leftmenu">Working with Parameterized Command objects</a></li>
                    <li><a href="#sto" class="leftmenu">Executing a Stored Procedure using DbCommand</a></li>
                    <li><a href="#dis" class="leftmenu">Understanding the Disconnected Layer of ADO.NET</a></li>
                    <li><a href="#ds" class="leftmenu">Understanding the role of the DataSet</a></li>
                    <li><a href="#dc" class="leftmenu">Working with DataColumns</a></li>
                    <li><a href="#dr" class="leftmenu">Working with DataRows</a></li>
                    <li><a href="#dt" class="leftmenu">Working with DataTables</a></li>                                        
                    <li><a href="#da" class="leftmenu">Working with DataAdapters</a></li>
                    <li><a href="#dv" class="leftmenu">Working with the DataView type</a></li>
                    <li><a href="#upd" class="leftmenu">Updating a Database using Data Adapter objects</a></li>
                    <li><a href="#rel" class="leftmenu">Multitabled DataSets and DataRelation objects</a></li>
                    <li><a href="#con" class="leftmenu">Using application configuration files</a></li>
                    <li><a href="#sum" class="leftmenu">Summary</a></li>
                    </ul>
                    <p class="normal">
                    The .NET platform defines a number of namespaces that allow you to interact with local and remote data stores. Collectively speaking, these namespaces are known as <i>ADO.NET</i>.<br />
                    The .NET platform supports numerous data providers, each of which is optimized to communicate with a specific database management system (Microsoft SQL Server, Oracle, MySQL, etc.).<br />
                    The remaining part of this chapter examines how to programmatically interact with relational databases using your data provider of choice. 
                    As you will see, ADO.NET provides two distinct ways to interface with a data source, often termed the <i>connected layer</i> and <i>disconnected layer</i>. 
                    You will come to know the role of connection objects, command objects, data readers, data adapters, and numerous types within the System.Data namespace 
                    (specifically, DataSet, DataTable, DataRow, DataColumn, DataView, and DataRelation).                    
                    </p>
                    <span id="int" class="style1">Introduction to ADO.NET</span>
                    <p class="normal">
                    The ADO.NET libraries can be used in two conceptually unique manners: connected or disconnected. When you are making use of the <i>connected layer</i>, your code base will explicitly connect to and disconnect from the underlying data store. 
                    When you are using ADO.NET in this manner, you typically interact with the data store using connection objects, command objects, and data reader objects. As you will see later in this chapter, 
                    data readers provide a way to pull records from a data store using a forward-only, read-only approach (much like a fire-hose cursor).<br />
                    The disconnected layer, on the other hand, allows you to obtain a set of DataTable objects (contained within a DataSet) that functions as a client-side copy of the external data. 
                    When you obtain a DataSet using a related data adapter object, the connection is automatically opened and closed on your behalf. As you would guess, this approach helps quickly free up connections for other callers. 
                    Once the client receives a DataSet, it is able to traverse and manipulate the contents without incurring the cost of network traffic. As well, if the client wishes to submit the changes back to the data store, 
                    the data adapter (in conjunction with a set of SQL statements) is used once again to update the data source, at which point the connection is closed immediately.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="pro" class="style1">Understanding ADO.NET Data Providers</span>
                    <p class="normal">
                    ADO.NET does not provide a single set of types that communicate with multiple database management systems (DBMSs). Rather, ADO.NET supports multiple <i>data providers</i>, each of which is optimized to interact with a specific DBMS. 
                    The first benefit of this approach is that a specific data provider can be programmed to access any unique features of the DBMS. Another benefit is that a specific data provider is able to directly connect to the underlying engine of the DBMS 
                    without an intermediate mapping layer standing between the tiers.<br />
                    Simply put, a <i>data provider</i> is a set of types defined in a given namespace that understand how to communicate with a specific data source. Regardless of which data provider you make use of, each defines a set of class types that provide core functionality. 
                    The below table documents some (but not all) of the core common objects.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Object</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">Connection</td>
                            <td>Provides the ability to connect to and disconnect from the data store. Connection objects also provide access to a related transaction object.</td>
                        </tr>
                        <tr>
                            <td valign="top">Command</td>
                            <td>Represents a SQL query or name of a stored procedure. Command objects also provide access to the provider's data reader object.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">DataReader</td>
                            <td>Provides forward-only, read-only access to data.</td>
                        </tr>
                        <tr>
                            <td valign="top">DataAdapter</td>
                            <td>Transfers DataSets between the caller and the data store. Data adapters contain a set of four internal command objects used to 
                            select, insert, update, and delete information from the data store.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">Parameter</td>
                            <td>Represents a named parameter within a parameterized query.</td>
                        </tr>
                        <tr>
                            <td valign="top">Transaction</td>
                            <td>Performs a database transaction.</td>
                        </tr>
                    </table>
                    <p class="normal">
                    Although the names of these types will differ among data providers (e.g., SqlConnection versus OracleConnection versus OdbcConnection versus MySqlConnection), 
                    each object derives from the same base class that implements identical interfaces. Given this, you are correct to assume that once you learn how to work with one data provider, 
                    the remaining providers are quite straightforward.
                    </p>
                    <div style="text-align:center;"><img alt="" src="images/2201.jpg" /></div><br />
                    <span class="style2">Microsoft-Supplied Data Providers</span>
                    <p class="normal">
                    As of version 2.0, Microsoft's .NET distribution ships with numerous data providers, including a provider for Oracle, SQL Server, and ODBC-style connectivity. 
                    The below table documents the namespace and containing assembly for each Microsoft ADO.NET data provider.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0" width="75%">
                        <tr>
                            <td class="header">Data Provider</td>
                            <td class="header">Namespace</td>
                            <td class="header">Assembly</td>
                        </tr>
                        <tr>
                            <td>Microsoft SQL Server</td>
                            <td>System.Data.SqlClient</td>
                            <td>System.Data.dll</td>
                        </tr>
                        <tr>
                            <td>Microsoft SQL Server Mobile</td>
                            <td>System.Data.SqlServerCe</td>
                            <td>System.Data.SqlServerCe.dll</td>
                        </tr>
                        <tr>
                            <td>Oracle</td>
                            <td>System.Data.OracleClient</td>
                            <td>System.Data.OracleClient.dll</td>
                        </tr>
                        <tr>
                            <td>OLE DB</td>
                            <td>System.Data.OleDb</td>
                            <td>System.Data.dll</td>
                        </tr>
                        <tr>
                            <td>ODBC</td>
                            <td>System.Data.Odbc</td>
                            <td>System.Data.dll</td>
                        </tr>
                    </table>
                    <p class="normal">
                    There is no specific data provider that maps directly to the Jet engine (and therefore Microsoft Access). If you wish to interact with an Access data file, you can do so using the OLE DB or ODBC data provider.<br />
                    The OLE DB data provider, which is composed of the types defined in the System.Data.OleDb namespace, allows you to access data located in any data store that supports the classic COM-based OLE DB protocol. 
                    Using this provider, you may communicate with any OLE DB–compliant database simply by tweaking the "Provider" segment of your connection string. Be aware, however, that the OLE DB provider interacts with various COM objects behind the scenes, 
                    which can affect the performance of your application. By and large, the OLE DB data provider is only useful if you are interacting with a DBMS that does not define a specific .NET data provider.<br />
                    The Microsoft SQL Server data provider offers direct access to Microsoft SQL Server data stores, and <i>only</i> SQL Server data stores (version 7.0 and greater). 
                    The System.Data.SqlClient namespace contains the types used by the SQL Server provider and offers the same basic functionality as the OLE DB provider. The key difference is that the SQL Server provider by passes the OLE DB layer and 
                    thus gives numerous performance benefits. As well, the Microsoft SQL Server data provider allows you to gain access to the unique features of this particular DBMS.<br /><br />
                    Reads third-party ADO.NET Data providers at page 763 of textbook.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="lay" class="style1">Understanding the Connected Layer of ADO.NET</span>
                    <p class="normal">
                    The connected layer of ADO.NET allows you to interact with a database using the connection, command, and data reader objects of your data provider. 
                    When you wish to connect to a database and read the records using a data reader object, you need to perform the following steps:
                    </p>
                    <ol>
                    <li>Allocate, configure, and open your connection object.</li>
                    <li>Allocate and configure a command object, specifying the connection object as a constructor argument or via the Connection property</li>
                    <li>Call ExecuteReader() on the configured command object.</li>
                    <li>Process each record using the Read() method of the data reader.</li>
                    </ol>
                    <span class="style2">Working with Connection objects</span>
                    <p class="normal">
                    The first step to take when working with a data provider is to establish a session with the data source using the connection object. .NET connection types are provided with a formatted <i>connection string</i>, 
                    which contains a number of name/value pairs separated by semicolons. This information is used to identify the name of the machine you wish to connect to, required security settings, the name of the database on that machine, 
                    and other data provider–specific information.<br />
                    Here is connection string to establish a session with Northwind database:<br />
                    <span class="sample">Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True</span><br />
                    In this connection string, the "Data Source" name identifies the name of the machine that maintains the database. If this machine is computer that hosts the application, you can use <b>localhost</b>, <b>(local)</b>, or simply <b>.</b> to assign value for "Data Source".<br />
                    The Initial Catalog name refers to the database you are attempting to establish a session with (Pubs, Northwind, Cars, etc.). In this session, you use security mode is Integrated Security.<br />
                    Once your construction string has been established, a call to Open() establishes your connection with the DBMS. In addition to the ConnectionString, Open(), and Close()members, a connection object provides a number of members that let you configure attritional settings regarding your connection, 
                    such as timeout settings and transactional information.<br />
                    Reads some members of the DbConnection base class at page 779 of textbook.
                    </p>
                    <span class="style2">Working with ConnectionStringBuilders</span>
                    <p class="normal">
                    Working with connection strings programmatically can be a bit clunky, given that they are often represented as string literals, which are difficult to maintain and error-prone at best. 
                    Under .NET 2.0, the Microsoft-supplied ADO.NET data providers now support <i>connection string builder objects</i>, which allow you to establish the name/value pairs using strongly typed properties. 
                    Consider the current Main()method:
                    </p>
                    <p class="sample">
<span class="keyword">static void</span> Main(<span class="keyword">string</span>[] args)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Create a connection string via the builder object.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlConnectionStringBuilder cnStrBuilder = <span class="keyword">new</span> SqlConnectionStringBuilder();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnStrBuilder.UserID = "sa";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnStrBuilder.Password = "";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnStrBuilder.InitialCatalog = "Cars";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnStrBuilder.DataSource = "(local)";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnStrBuilder.ConnectTimeout = 30;<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlConnection cn = <span class="keyword">new</span> SqlConnection();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cn.ConnectionString = cnStrBuilder.ConnectionString;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cn.Open();<br />                    
}
                    </p>
                    <span class="style2">Working with Command objects</span>
                    <p class="normal">
                    Now that you better understand the role of the connection object, the next order of business is to check out how to submit SQL queries to the database in question. 
                    The SqlCommand type (which derives from DbCommand) is an OO representation of a SQL query, table name, or stored procedure. The type of command is specified using the CommandType property, 
                    which may take any value from the CommandType enum:<br />
                    <span class="sample">
<span class="keyword">public enum</span> System.Data.CommandType<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StoredProcedure, TableDirect,<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Text&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Default value.</span><br />
}                    
                    </span><br />
                    When creating a command object, you may establish the SQL query as a constructor parameter or directly via the CommandText property. 
                    Also when you are creating a command object, you need to specify the connection to be used. Again, you may do so as a constructor parameter or via the Connection property:                    
                    </p>
                    <p class="sample">
<span class="keyword">static void</span> Main(<span class="keyword">string</span>[] args)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlConnection cn = <span class="keyword">new</span> SqlConnection();<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Create command object via ctor args.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">string</span> strSQL = "Select * From Employees";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand myCommand = <span class="keyword">new</span> SqlCommand(strSQL, cn);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Create another command object via properties.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand testCommand = <span class="keyword">new</span> SqlCommand();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testCommand.Connection = cn;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;testCommand.CommandText = strSQL;<br />
}                    
                    </p>
                    <p class="normal">
                    Realize that at this point, you have not literally submitted the SQL query to the Northwind database, but rather prepped the state of the command type for future use. 
                    The below table highlights some additional members of the DbCommand type.</p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header">Member</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">CommandTimeout</td>
                            <td>Gets or sets the time to wait while executing the command before terminating the attempt and generating an error. The default is 30 seconds.</td>
                        </tr>
                        <tr>
                            <td valign="top">Connection</td>
                            <td>Gets or sets the DbConnection used by this instance of the DbCommand.</td>
                        </tr>
                        <tr>
                            <td valign="top">Parameters</td>
                            <td>Gets the collection of DbParameter types used for a parameterized query.</td>
                        </tr>
                        <tr>
                            <td valign="top">Cancel()</td>
                            <td>Cancels the execution of a command.</td>
                        </tr>
                        <tr>
                            <td valign="top">ExecuteReader()</td>
                            <td>Returns the data provider's DbDataReader object, which provides forward-only, read-only access to the underlying data.</td>
                        </tr>
                        <tr>
                            <td valign="top">ExecuteNonQuery()</td>
                            <td>Issues the command text to the data store.</td>
                        </tr>
                        <tr>
                            <td valign="top">ExecuteScalar()</td>
                            <td>A lightweight version of the ExecuteNonQuery()method, designed specifically for singleton queries (such as obtaining a record count).</td>
                        </tr>
                        <tr>
                            <td valign="top">ExecuteXmlReader()</td>
                            <td>Microsoft SQL Server (2000 and higher) is capable of returning result sets as XML. As you might suspect, this method returns a System.Xml.XmlReader that 
                            allows you to process the incoming stream of XML.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">Prepare()</td>
                            <td>Creates a prepared (or compiled) version of the command on the data source. As you may know, a prepared query executes slightly faster and 
                            is useful when you wish to execute the same query multiple times.
                            </td>
                        </tr>
                    </table><br />
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="rea" class="style1">Working with Data Readers</span>
                    <p class="normal">
                    Once you have established the active connection and SQL command, the next step is to submit the query to the data source. As you might guess, you have a number of ways to do so. 
                    The DbDataReader type (which implements IDataReader) is the simplest and fastest way to obtain information from a data store. Recall that data readers represent a read-only, forward-only stream of data returned one record at a time. 
                    Given this, it should stand to reason that data readers are useful only when submitting SQL selection statements to the underlying data store.<br />
                    Data readers are useful when you need to iterate over large amounts of data very quickly and have no need to maintain an in-memory representation. For example, if you request 20,000 records from a table to store in a text file, 
                    a better approach is to create a data reader that spins over each record as rapidly as possible. Be aware, however, that data reader objects maintain an open connection to their data source until you explicitly close the session.<br />
                    Data reader objects are obtained from the command object via a call to ExecuteReader().When invoking this method, you may optionally instruct the reader to automatically close down the related connection object by specifying CommandBehavior.CloseConnection.<br />
                    The following use of the data reader leverages the Read()method to determine when you have reached the end of your records (via a false return value). For each incoming record, 
                    you are making use of the type indexer to print out LastName, FirstName and Title of each Employee. Also note that you call Close() as soon as you are finished processing the records, to free up the connection object.
                    </p>
                    <p class="sample">
        <span class="keyword">static void</span> Main(<span class="keyword">string</span>[] args)<br />
        {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">string</span> cnnString = @"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True";<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlConnection cn = <span class="keyword">new</span> SqlConnection(cnnString);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cn.Open();<br /><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">string</span> query = "Select * from Employees";<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand cmd = new SqlCommand(query, cn);<br /><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Obtain a data reader.</span><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlDataReader dr = cmd.ExecuteReader(CommandBehavior.CloseConnection);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("List of Employees");<br /><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Loop over the results.</span><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">while</span> (dr.Read())<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.Write("Employee {0}:\t", dr["EmployeeID"]);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.Write("Name: {0} {1}\t", dr["FirstName"], dr["LastName"]);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Title: {0}", dr["Title"]);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dr.Close();<br />
        }                    
                    </p>
                    <p class="normal">
                    The indexer of a data reader object has been overloaded to take either a string (representing the name of the column) or an integer (representing the column’s ordinal position).<br />
                    If you compile and run your project, you should be presented with a list of all employees in the Employees table of the Northwind database.                    
                    </p>
                    <div style="text-align:center;"><img alt="" src="images/2202.jpg" /></div>
                    <p class="normal">Reads obtaining multiple result sets using a Data Reader at page 784 of textbook.</p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="com" class="style1">Modify tables using Command objects</span>
                    <p class="normal">
                    The ExecuteReader()method extracts a data reader object that allows you to examine the results of a SQL Select statement using a forward-only, read-only flow of information. 
                    However, when you wish to submit SQL commands that result in the modification of a given table, you will call the ExecuteNonQuery()method of your command object. 
                    This single method will perform inserts, updates, and deletes based on the format of your command text.<br />
                    Reads example of inserting new records, delete existing records, and updating existing records at page 786 to 788 of textbook.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="par" class="style1">Working with Parameterized Command objects</span>
                    <p class="normal">
                    The previous insert, update, and delete logic works as expected; however, note that each of your SQL queries is represented using hard-coded string literals. 
                    As you may know, a <i>parameterized query</i> can be used to treat SQL parameters as objects, rather than a simple blob of text. Typically, parameterized queries execute much faster than a literal SQL string, 
                    in that they are parsed exactly once (rather than each time the SQL string is assigned to the CommandText property). As well, parameterized queries also help protect against SQL injection attacks 
                    (a well-known data access security issue).<br />
                    ADO.NET command objects maintain a collection of discrete parameter types. By default this collection is empty, but you are free to insert any number of parameter objects that map to a "placeholder parameter" in the SQL query. 
                    When you wish to associate a parameter within a SQL query to a member in the command object's parameters collection, prefix the SQL text parameter with an at(@) symbol (at least when using Microsoft SQL Server; not all DBMSs support this notation).
                    </p>
                    <span class="style2">Specifying Parameters using the DbParameter type</span>
                    <p class="normal">
                    Before you build a parameterized query, let's get to know the DbParameter type (which is the base class to a provider's specific parameter object). 
                    This class maintains a number of properties that allow you to configure the name, size, and data type of the parameter, as well as other characteristics such as the parameter's direction of travel. 
                    The below table describes some key properties of the DbParameter type.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Property</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">DbType</td>
                            <td>Gets or sets the native data type from the data source, represented as a CLR data type.</td>
                        </tr>
                        <tr>
                            <td valign="top">Direction</td>
                            <td>Gets or sets whether the parameter is input-only, output-only, bidirectional, or a return value parameter.</td>
                        </tr>
                        <tr>
                            <td valign="top">IsNullable</td>
                            <td>Gets or sets whether the parameter accepts null values.</td>
                        </tr>
                        <tr>
                            <td valign="top">ParameterName</td>
                            <td>Gets or sets the name of the DbParameter.</td>
                        </tr>
                        <tr>
                            <td valign="top">Size</td>
                            <td>Gets or sets the maximum parameter size of the data.</td>
                        </tr>
                        <tr>
                            <td valign="top">Value</td>
                            <td>Gets or sets the value of the parameter.</td>
                        </tr>
                    </table>
                    <p class="normal">To illustrate, this example is making use of parameter objects to add information of a new employee.</p>
<p class="sample">
<span class="keyword">private static void</span> InsertNewEmployee(SqlConnection cn)<br />
        {<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Note the 'placeholders' in the SQL query.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">string</span> query = "Insert Into Employees (LastName, FirstName, Title, BirthDate) Values (@lastName, @firstName, @title, @birthDate)";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Fill params collection.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlCommand cmd = <span class="keyword">new</span> SqlCommand(query, cn);<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlParameter param = <span class="keyword">new</span> SqlParameter();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.ParameterName = "@lastName";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Value = "Nguyen";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.SqlDbType = SqlDbType.NVarChar;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Size = 20;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.Add(param);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param = <span class="keyword">new</span> SqlParameter();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.ParameterName = "@firstName";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Value = "Van A";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.SqlDbType = SqlDbType.NVarChar;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Size = 10;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.Add(param);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param = <span class="keyword">new</span> SqlParameter();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.ParameterName = "@title";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Value = "Staff";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.SqlDbType = SqlDbType.NVarChar;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Size = 30;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.Add(param);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param = <span class="keyword">new</span> SqlParameter();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.ParameterName = "@birthDate";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.Value = "01 Jan 1989";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;param.SqlDbType = SqlDbType.DateTime;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd.Parameters.Add(param);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cmd.ExecuteNonQuery();<br />
        }
</p>                    
                    <p class="normal">
                    While building a parameterized query requires a larger amount of code, the end result is a more convenient way to tweak SQL statements programmatically as well as better overall performance. 
                    While you are free to make use of this technique whenever a SQL query is involved, parameterized queries are most helpful when you wish to trigger a stored procedure.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="sto" class="style1">Executing a Stored Procedure using DbCommand</span>
                    <p class="normal">
                    A <i>stored procedure</i> is a named block of SQL code stored in the database. Stored procedures can be constructed to return a set of rows or scalar data types and may take any number of optional parameters. 
                    The end result is a unit of work that behaves like a typical function, with the obvious difference of being located on a data store rather than a binary business object.<br />
                    When you wish to execute a stored procedure, you begin as always by creating a new connection object, configuring your connection string, and opening the session. 
                    However, when you creat your command object, the CommandText property is set to the name of the stored procedure (rather than a SQL query). As well, you must be sure to set the CommandType property to CommandType.StoredProcedure 
                    (the default is CommandType.Text).<br />
                    Notice that the Direction property of the parameter object allows you to specify input and output parameters. Once the stored procedure completes via a call to ExecuteNonQuery(), 
                    you are able to obtain the value of the output parameter by investigating the command object's parameter collection.<br /><br />
                    Reads example of executing GetPetName stored procedure at page 790, 791 of textbook.
                    </p>                    
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="dis" class="style1">Understanding the Disconnected Layer of ADO.NET</span>
                    <p class="normal">
                    When you work with the disconnected layer of ADO.NET, you will still make use of connection and command objects. In addition, you will leverage a specific object named a <i>data adapter</i> 
                    (which extends the abstract DbDataAdapter) to fetch and update data. Unlike the connected layer, data obtained via a data adapter is not processed using data reader objects. 
                    Rather, data adapter objects make use of DataSet objects to move data between the caller and data source. The DataSet type is a container for any number of DataTable objects, 
                    each of which contains a collection of DataRow and DataColumn objects.<br />
                    The data adapter object of your data provider handles the database connection automatically. In an attempt to increase scalability, data adapters keep the connection open for the shortest possible amount of time. 
                    Once the caller receives the DataSet object, he is completely disconnected from the DBMS and left with a local copy of the remote data. The caller is free to insert, delete, or update rows from a given DataTable, 
                    but the physical database is not updated until the caller explicitly passes the DataSet to the data adapter for updating. In a nutshell, DataSets allow the clients to pretend they are indeed always connected, 
                    when in fact they are operating on an in-memory database.
                    </p>
                    <div style="text-align:center;"><img alt="" src="images/2203.jpg" /></div>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="ds" class="style1">Understanding the role of the DataSet</span>
                    <p class="normal">A DataSet is an in-memory representation of external data. More specifically, a DataSet is a class type that maintains three internal strongly typed collections.</p>
                    <div style="float:left;height:220;width:250;text-align:center;"><img alt="" src="images/2204.jpg" /></div>
                    <div style="float:right;height:220;width:575;">
                    <p class="normal">
                    The Tables property of the DataSet allows you to access the DataTableCollection that contains the individual DataTables. Another important collection used by the DataSet is the DataRelationCollection. 
                    Given that a DataSet is a disconnected version of a database schema, it can programmatically represent the parent/child relationships between its tables. 
                    For example, a relation can be created between two tables to model a foreign key constraint using the DataRelation type. This object can then be added to the DataRelationCollection through the Relations property. 
                    At this point, you can navigate between the connected tables as you search for data.
                    </p>
                    </div>
                    <p class="normal">
                    The ExtendedProperties property provides access to the PropertyCollection object, which allows you to associate any extra information to the DataSet as name/value pairs. 
                    This information can literally be anything at all, even if it has no bearing on the data itself. For example, you can associate your company's name to a DataSet, 
                    which can then function as in-memorymetadata. Other examples of extended properties might include timestamps, an encrypted password that must be supplied to access the contents of the DataSet, 
                    a number representing a data refresh rate, and so forth.<br />
                    Reads some core methods of DataSet at page 795 of textbook.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="dc" class="style1">Working with DataColumns</span>
                    <p class="normal">
                    The DataColumn type represents a single column within a DataTable. Collectively speaking, the set of all DataColumn types bound to a given DataTable represents the foundation of a table's schema information. 
                    Once you have created your DataColumn objects, they are typically added into the columns collection of the DataTable type (via the Columns property).<br />
                    If you have a background in relational database theory, you know that a given column in a data table can be assigned a set of constraints 
                    (e.g., configured as a primary key, assigned a default value, configured to contain read-only information, etc.). Also, every column in a table must map to an underlying data type.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Properties</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">AllowDBNull</td>
                            <td>This property is used to indicate if a row can specify null values in this column. 
                            The default value is true.</td>
                        </tr>
                        <tr>
                            <td valign="top">AutoIncrement</td>
                            <td valign="top" rowspan="3">
                            These properties are used to configure the autoincrement behavior for a given column. This can be helpful when you wish to ensure unique values in a given DataColumn 
                            (such as a primary key). By default, a DataColumn does not support autoincrement behavior.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">AutoIncrementSeed</td>                            
                        </tr>
                        <tr>
                            <td valign="top">AutoIncrementStep</td>                            
                        </tr>
                        <tr>
                            <td valign="top">Caption</td>
                            <td>This property gets or sets the caption to be displayed for this column.</td>
                        </tr>
                        <tr>
                            <td valign="top">ColumnMapping</td>
                            <td>This property determines how a DataColumn is represented when a DataSet is saved as an XML document using the DataSet.WriteXml()method.</td>
                        </tr>
                        <tr>
                            <td valign="top">ColumnName</td>
                            <td>
                            This property gets or sets the name of the column in the Columns collection (meaning how it is represented internally by the DataTable). 
                            If you do not set the ColumnName explicitly, the default values are Column with (n+1) numerical suffixes (i.e., Column1, Column2, Column3, etc.).
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">DataType</td>
                            <td>This property defines the data type (Boolean, string, float, etc.) stored in the column.</td>
                        </tr>
                        <tr>
                            <td valign="top">DefaultValue</td>
                            <td>This property gets or sets the default value assigned to this column when inserting new rows. This is used if not otherwise specified.</td>
                        </tr>
                        <tr>
                            <td valign="top">Expression</td>
                            <td>This property gets or sets the expression used to filter rows, calculate a column's value, or create an aggregate column.</td>
                        </tr>
                        <tr>
                            <td valign="top">Ordinal</td>
                            <td>This property gets the numerical position of the column in the Columns collection maintained by the DataTable.</td>
                        </tr>
                        <tr>
                            <td valign="top">ReadOnly</td>
                            <td>This property determines if this column can be modified once a row has been added to the table. The default is false.</td>
                        </tr>
                        <tr>
                            <td valign="top">Table</td>
                            <td>This property gets the DataTable that contains this DataColumn.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unique</td>
                            <td>
                            This property gets or sets a value indicating whether the values in each row of the column must be unique or if repeating values are permissible. 
                            If a column is assigned a primary key constraint, the Unique property should be set to true.
                            </td>
                        </tr>
                    </table><br />
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="dr" class="style1">Working with DataRows</span>
                    <p class="normal">
                    As you have seen, a collection of DataColumn objects represents the schema of a DataTable. In contrast, a collection of DataRow types represents the actual data in the table. 
                    Thus, if you have 9 records in the Employees table of the Northwind database, you can represent these records using 9 DataRow types. 
                    Using the members of the DataRow class, you are able to insert, remove, evaluate, and manipulate the values in the table. 
                    The below table documents some of the members of the DataRow type.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Members</td>
                            <td class="header">Meaning iyn Life</td>
                        </tr>
                        <tr>
                            <td valign="top">HasErrors</td>
                            <td valign="top" rowspan="5">
                            The HasErrors property returns a Boolean value indicating if there are errors.<br />
                            If so, the GetColumnsInError()method can be used to obtain the offending members, 
                            and GetColumnError() can be used to obtain the error description, while the ClearErrors()method removes each error listing for the row.<br />
                            The RowError property allows you to configure a textual description of the error for a given row.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">GetColumnsInError</td>                            
                        </tr>
                        <tr>
                            <td valign="top">GetColumnError</td>                            
                        </tr>
                        <tr>
                            <td valign="top">ClearErrors</td>                            
                        </tr>
                        <tr>
                            <td valign="top">RowError</td>                            
                        </tr>
                        <tr>
                            <td valign="top">ItemArray</td>
                            <td>This property gets or sets all of the values for this row using an array of objects.</td>
                        </tr>
                        <tr>
                            <td valign="top">RowState</td>
                            <td>This property is used to pinpoint the current "state" of the DataRow using values of the RowState enumeration.</td>
                        </tr>
                        <tr>
                            <td valign="top">Table</td>
                            <td>This property is used to obtain a reference to the DataTable containing this DataRow.</td>
                        </tr>
                        <tr>
                            <td valign="top">AcceptChanges()</td>
                            <td valign="top" rowspan="2">These methods commit or reject all changes made to this row since the last time AcceptChanges() was called.</td>
                        </tr>
                        <tr>
                            <td valign="top">RejectChanges()</td>                            
                        </tr>
                        <tr>
                            <td valign="top">BeginEdit()</td>
                            <td valign="top" rowspan="3">These methods begin, end, or cancel an edit operation on a DataRow object.</td>
                        </tr>
                        <tr>
                            <td valign="top">EndEdit()</td>                            
                        </tr>
                        <tr>
                            <td valign="top">CancelEdit()</td>                            
                        </tr>
                        <tr>
                            <td valign="top">Delete()</td>
                            <td>This method marks this row to be removed when the AcceptChanges() method is called.</td>
                        </tr>
                        <tr>
                            <td valign="top">IsNull()</td>
                            <td>This method gets a value indicating whether the specified column contains a null value.</td>
                        </tr>
                    </table>
                    <p class="normal">
                    Working with a DataRow is a bit different from working with a DataColumn, because you cannot create a direct instance of this type; 
                    rather, you obtain a reference from a given DataTable. For example, assume you wish to insert two rows in the Inventory table. 
                    The DataTable.NewRow()method allows you to obtain the next slot in the table, at which point you can fill each column with new data via the type indexer, as shown here:
                    </p>
                    <p class="sample">
<span class="keyword">static void</span> Main(<span class="keyword">string</span>[] args)<br />
{<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Now add some rows to the Inventory Table.</span><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataRow carRow = inventoryTable.NewRow();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["Make"] = "BMW";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["Color"] = "Black";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["PetName"] = "Hamlet";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inventoryTable.Rows.Add(carRow);<br /><br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow = inventoryTable.NewRow();<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["Make"] = "Saab";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["Color"] = "Red";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;carRow["PetName"] = "Sea Breeze";<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inventoryTable.Rows.Add(carRow);<br />
}                    
                    </p>
                    <p class="normal">Notice how the DataRow class defines an indexer that can be used to gain access to a given DataColumn by numerical position as well as column name.</p>
                    <span class="style2">Understanding the DataRow.RowState property</span>
                    <p class="normal">
                    The RowState property is useful when you need to programmatically identify the set of all rows in a table that have changed, have been newly inserted, and so forth. 
                    This property may be assigned any value from the DataRowState enumeration, as shown in the below table.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Value</td>
                            <td class="header">Meaning iyn Life</td>
                        </tr>
                        <tr>
                            <td valign="top">Added</td>
                            <td>The row has been added to a DataRowCollection, and AcceptChanges() has not been called.</td>
                        </tr>
                        <tr>
                            <td valign="top">Deleted</td>
                            <td>The row has been deleted via the Delete()method of the DataRow.</td>
                        </tr>
                        <tr>
                            <td valign="top">Detached</td>
                            <td>
                            The row has been created but is not part of any DataRowCollection. A DataRow is in this state immediately after it has been created and 
                            before it is added to a collection, or if it has been removed from a collection.
                            </td>
                        </tr>
                        <tr>
                            <td valign="top">Modified</td>
                            <td>The row has been modified, and AcceptChanges() has not been called.</td>
                        </tr>
                        <tr>
                            <td valign="top">Unchanged</td>
                            <td>The row has not changed since AcceptChanges() was last called.</td>
                        </tr>
                    </table>
                    <p class="normal">
                    As you can see, the ADO.NET DataRow is smart enough to remember its current state of affairs. Given this, the owning DataTable is able to identify which rows have been modified. 
                    This is a key feature of the DataSet, as when it comes time to send updated information to the data store, only the modified data is submitted.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="dt" class="style1">Working with DataTables</span>
                    <p class="normal">
                    The DataTable defines a good number of members, many of which are identical in name and functionality to those of the DataSet. 
                    The below table describes some core properties of the DataTable type beyond Rows and Columns.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Property</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">CaseSensitive</td>
                            <td>Indicates whether string comparisons within the table are case sensitive (or not). 
                            The default value is false.</td>
                        </tr>
                        <tr>
                            <td valign="top">ChildRelations</td>
                            <td>Returns the collection of child relations for this DataTable (if any).</td>
                        </tr>
                        <tr>
                            <td valign="top">Constraints</td>
                            <td>Gets the collection of constraints maintained by the table.</td>
                        </tr>
                        <tr>
                            <td valign="top">DataSet</td>
                            <td>Gets the DataSet that contains this table (if any).</td>
                        </tr>
                        <tr>
                            <td valign="top">DefaultView</td>
                            <td>Gets a customized view of the table that may include a filtered view or a cursor position.</td>
                        </tr>
                        <tr>
                            <td valign="top">MinimumCapacity</td>
                            <td>Gets or sets the initial number of rows in this table (the default is 25).</td>
                        </tr>
                        <tr>
                            <td valign="top">ParentRelations</td>
                            <td>Gets the collection of parent relations for this DataTable.</td>
                        </tr>
                        <tr>
                            <td valign="top">PrimaryKey</td>
                            <td>Gets or sets an array of columns that function as primary keys for the data table.</td>
                        </tr>                        
                        <tr>
                            <td valign="top">TableName</td>
                            <td>Gets or sets the name of the table. This same property may also be specified as a constructor parameter.</td>
                        </tr>
                    </table><br />
                    <span class="style2">Working with .NET 2.0 DataTableReaders</span>
                    <p class="normal">
                    DataTables provide a number of methods beyond what we’ve examined thus far. For example, like DataSets, DataTables support 
                    AcceptChanges(), GetChanges(), Copy(), and ReadXml()/WriteXml() methods. As of .NET 2.0, DataTables also now support a method named CreateDataReader(). 
                    This method allows you to obtain the data within a DataTable using a data reader–like navigation scheme (forward-only, read-only).<br />
                    Reads example of creating a new helper function named PrintTable at page 802 of textbook.
                    </p>                    
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="da" class="style1">Working with DataAdapters</span>
                    <p class="normal">
                    Data adapter objects are used to fill a DataSet with DataTable objects and send modified DataTables back to the database for processing. 
                    The below table documents the core members of the DbDataAdapter base class.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header" style="width:15%">Members</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">SelectCommand</td>
                            <td valign="top" rowspan="4">
                            Establish SQL commands that will be issued to the data store when the Fill() and Update() methods are called.</td>
                        </tr>
                        <tr>
                            <td valign="top">InsertCommand</td>                            
                        </tr>
                        <tr>
                            <td valign="top">UpdateCommand</td>                            
                        </tr>
                        <tr>
                            <td valign="top">DeleteCommand</td>                            
                        </tr>
                        <tr>
                            <td valign="top">Fill()</td>
                            <td>Fills a given table in the DataSet with some number of records based on the command object–specified SelectCommand.</td>
                        </tr>
                        <tr>
                            <td valign="top">Update()</td>
                            <td>
                            Updates a DataTable using command objects within the InsertCommand, UpdateCommand, or DeleteCommand property. 
                            The exact command that is executed is based on the RowState value for a given DataRow in a given DataTable (of a given DataSet).
                            </td>
                        </tr>
                    </table>
                    <p class="normal">
                    Data adapter objects manage the underlying connection to the database on your behalf; therefore, you will not need to explicitly open or close your session with the DBMS. 
                    However, you will still need to supply the data adapter with a valid connection object or a connection string (which will be used to build a connection object internally) as a constructor argument.
                    </p>
                    <span class="style2">Filling a DataSet using a Data Adapter</span>
                    <p class="normal">
                    The data adapter has been constructed by specifying a SQL Select statement. This value will be used to build a command object internally, which can be later obtained via the SelectCommand property. 
                    Next, notice that the Fill()method takes an instance of the DataSet type and optionally a string name that will be used to set the TableName property of the new DataTable 
                    (if you do not specify a table name, the data adapter will simply name the table "Table").<br />
                    Consider the following example of getting data of Employees table in Northwind database and binding it to a DataGridView control.
                    </p>
                    <p class="sample">
        <span class="keyword">private void</span> Employees_Load(<span class="keyword">object</span> sender, EventArgs e)<br />
        {<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">string</span> cnnString = @"Data Source=localhost;Initial Catalog=Northwind;Integrated Security=True";<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Fill the DataSet with a new DataTable.</span><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;DataSet ds = <span class="keyword">new</span> DataSet("Northwind");<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SqlDataAdapter da = <span class="keyword">new</span> SqlDataAdapter("Select * From Employees", cnnString);<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;da.Fill(ds, "Employees");<br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">// Bind to grid.</span><br />
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dgvEmployees.DataSource = ds.Tables["Employees"];<br />
        }                    
                    </p>
                    <p class="normal">Here is output of this example.</p>
                    <div style="text-align:center;"><img alt="" src="images/2205.jpg" /></div>
                    <p class="normal">Reads mapping Database names to Friendly names at page 813 of textbook.</p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="dv" class="style1">Working with the DataView type</span>
                    <p class="normal">
                    In ADO.NET, the DataView type allows you to programmatically extract a subset of data from the DataTable into a stand-alone object.<br />
                    One great advantage of holding multiple views of the same table is that you can bind these views to various GUI widgets (such as the DataGridView). 
                    For example, one DataGridView might be bound to a DataView showing all employees in the Northwind database, while another might be configured to 
                    display only employees who live in USA.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>                    
                    <span id="upd" class="style1">Updating a Database using Data Adapter objects</span>
                    <p class="normal">
                    Not only do data adapters fill the tables of a DataSet on your behalf, but they are also in charge of maintaining a set of core SQL command objects used to push updates back to the data store. 
                    When you call the Update()method of a given data adapter, it will examine the RowState property for each row in the DataTable and 
                    use the correct SQL commands assigned to the DeleteCommand, InsertCommand, and UpdateCommand properties to push the changes within a given DataTable back to the data source.<br />
                    When you are using a data adapter to update a DataSet, the first order of business is to assign the UpdateCommand, DeleteCommand, and InsertCommand properties with valid command objects 
                    (until you do so, these properties return null!). By "valid" command objects, the set of command objects you plug into a data adapter will change based on the table you are attempting to update.                    
                    </p>
                    <span class="style2">Autogenerating SQL Commands using Command Builder types</span>
                    <p class="normal">
                    You might agree that working with data adapters can entail a fair amount of code, given the need to build each of the four command objects and the associated connection string .
                    To help simplify matters, each of the ADO.NET data providers that ships with .NET 2.0 provides a <i>command builder</i> type. Using this type, 
                    you are able to automatically obtain command objects that contain the correct Insert, Delete, and Update command types based on the initial Select statement.<br />
                    An obvious question at this point is how a command builder is able to build these SQL command objects on the fly. The short answer is metadata. 
                    At runtime, when you call the Update()method of a data adapter, the related command builder will read the database's schema data to autogenerate the underlying insert, delete, and update command objects.<br />
                    Now, while you may love the idea of getting something for nothing, do understand that command builders come with some critical restrictions. 
                    Specifically, a command builder is only able to autogenerate SQL commands for use by a data adapter if all of the following conditions are true:
                    </p>
                    <ul>
                    <li>The Select command interacts with only a single table (e.g., no joins).</li>
                    <li>The single table has been attributed with a primary key.</li>
                    <li>The column(s) representing the primary key is accounted for in your SQL Select statement.</li>
                    </ul>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="rel" class="style1">Multitabled DataSets and DataRelation objects</span>
                    <p class="normal">
                    Currently, all of this chapter's examples involved DataSets that contained a single DataTable object. However, 
                    the power of the disconnected layer really comes to light when a DataSet object contains numerous interrelated DataTables. 
                    In this case, you are able to insert any number of DataRelation objects into the DataSet's DataRelation collection to account for the interdependencies of the tables. 
                    Using these objects, the client tier is able to navigate between the table data without incurring network round-trips.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="con" class="style1">Using application configuration files</span>
                    <p class="normal">
                    To further increase the flexibility of your ADO.NET applications, you could incorporate a client-side *.config file that makes use of custom key/value pairs within the &lt;appSettings&gt; element. 
                    Recall from Chapter 11 that custom data can be programmatically obtained using types within the System.Configuration namespace. For example, 
                    assume you have specified the connection string and data provider values within a configuration file as so:
                    </p>
                    <p class="sample">
&lt;configuration&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;appSettings&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;add key="provider" value="SqlServer" /&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;add key="cnStr" value="Data Source=localhost;uid=sa;pwd=;Initial Catalog=Pubs"/&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/appSettings&gt;<br />
&lt;/configuration&gt;<br />
                    </p>
                    <p class="normal">
                    To read the value of connection string in file *.config, you should use the below syntax:<br />
                    <span class="sample">
                    <span class="keyword">string</span> cnnString = ConfigurationManager.AppSettings["cnStr"];
                    </span><br /><br />
                    Beside of &lt;appSettings&gt;, application configuration files may define a new element named &lt;connectionStrings&gt;. Within this element, 
                    you are able to define any number of name/value pairs that can be programmatically read into memory using the ConfigurationManager.ConnectionStrings indexer. 
                    The chief advantage of this approach (rather than using the &lt;appSettings&gt; element and the ConfigurationManager.AppSettings indexer) is that 
                    you can define multiple connection strings for a single application in a consistent manner.<br />
                    To illustrate, update your current app.config file as follows (note that each connection string is documented using the name and connectionString attributes 
                    rather than the key and value attributes as found in &lt;appSettings&gt;):
                    </p>
                    <p class="sample">
&lt;configuration&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;appSettings&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;add key="provider" value="SqlServer" /&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/appSettings&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;connectionStrings&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;add name ="SqlProviderPubs" connectionString = "Data Source=localhost;uid=sa;pwd=;Initial Catalog=Pubs"/&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;add name ="OleDbProviderPubs" connectionString = " Provider=SQLOLEDB.1;Data Source=localhost;uid=sa;pwd=;Initial Catalog=Pubs"/&gt;<br />
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;/connectionStrings&gt;<br />
&lt;/configuration&gt;<br />
                    </p>
                    <p class="normal">And syntax to read the value of connection string is:<br />
                    <span class="sample">
                    <span class="keyword">string</span> cnStr = ConfigurationManager.ConnectionStrings["SqlProviderPubs"].ConnectionString;
                    </span>
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>                    
                    <span id="sum" class="style1">Summary</span>
                    <p class="normal">
                    ADO.NET is a new data access technology developed with the disconnected n-tier application firmly in mind. The System.Data namespace contains most of the core types you need to programmatically interact with rows, columns, tables, and views. 
                    As you have seen, the .NET platform ships with numerous data providers that allow you to leverage the connected and disconnected layers of ADO.NET.<br />
                    Using connection objects, command objects, and data reader objects of the connected layer, you are able to select, update, insert, and delete records. 
                    As you have seen, command objects support an internal parameter collection, which can be used to add some type safety to your SQL queries and are quite helpful when triggering stored procedures.<br />
                    The centerpiece of the disconnected layer is the DataSet. This type is an in-memory representation of any number of tables and any number of optional interrelationships, constraints, and expressions. 
                    The beauty of establishing relations on your local tables is that you are able to programmatically navigate between them while disconnected from the remote data store.<br />
                    You also examined the role of the data adapter in this chapter. Using this type (and the related SelectCommand, InsertCommand, UpdateCommand, and DeleteCommand properties), 
                    the adapter can resolve changes in the DataSet with the original data store. Also, you learned about the connected layer of ADO.NET and came to understand the role of data reader types.
                    </p>
                    </div>
                    </td>
                  </tr>
                </table>
                </td>
              </tr>
            </table>
            </td>
          </tr>
          <tr>
            <td width="100%" style="border-bottom:1px solid #006666; border-left:1px solid #006666; border-right:1px solid #006666; border-top-style: none; border-top-width: medium; " align="center" colspan="5" bgcolor="#006666" height="1">
            <p style="margin-top: 3; margin-bottom: 3"><b>
            <font face="Verdana" size="1" color="#FFFFFF">Copyright 2010
             All Rights Reserved.
             </font></b></p></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>    
      </center>
    </div>    
</body>
</html>