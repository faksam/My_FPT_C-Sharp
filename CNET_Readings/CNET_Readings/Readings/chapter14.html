<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
<title>FPT University - C# & .NET technology</title>
<link rel="stylesheet" href="cf112.css" type="text/css" charset="utf-8" />
</head>
<body>
    <div align="center">
      <center>
    <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0; bordercolor: #111111" width="1024" id="AutoNumber6">
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; height:168px" height="2" bgcolor="#339966" bordercolor="#333333" background="images/background.jpg"><br /><br />
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0; text-align:center" ><br/>
        <b><font size="5" color="#FFFFFF" face="Arial Black">Software Development</font></b></p>
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0"><i>
        <font face="Arial Black" color="#FFCC00">&nbsp;</font></i><br/>
        <br/></p>&nbsp;</td>
      </tr>
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; bordercolor:#333333" bgcolor="#FFFFFF" valign="top">
        <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 0; border-right-width: 0; border-bottom-width:0" bordercolor="#006666" width="100%" id="AutoNumber7" height="8">
          <tr>
            <td width="12%" style="border-left: 1px solid #006666; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="index.html">Home</a></td>
            <td width="18%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="outline.html">Outline</a></td>
            <td width="26%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="timeline.html">Timeline</a></td>
            <td width="24%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="readings.html">Readings</a></td>
            <td width="20%" style="border-left-style: solid; border-left-width: 1; border-right: 1px solid #006666; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="instructors.html">Instructors</a></td>
          </tr>
          <tr>
            <td width="100%" style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: solid; border-top-width: 1; border-bottom-style: none; border-bottom-width: medium" align="center" colspan="5">
            <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0" bordercolor="#111111" width="100%" id="AutoNumber8">
              <tr>
                <td width="100%" style="border-style: none; border-width: medium">
                <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 2; border-right-width: 2; border-top-width: 2; border-bottom-width: 0" bordercolor="#006666" id="AutoNumber9" height="1">
                  <tr>
                    <td width="100%" style="border-style: none; border-width: medium" height="1" colspan="2" bgcolor="#004646">
                    <p style="margin-top: -6; margin-bottom: -6"/></td>
                  </tr>
                  <tr>
                    <td style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: none; border-top-width: medium; border-bottom: 2px none #006666" height="1" bgcolor="#006666" valign="top">
                    <div align="center" style="width: 169">
                      <center>
                      <p style="margin-top: -4; margin-bottom: -4">&nbsp;</p>
                      <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" width="91%" id="AutoNumber10" bgcolor="#FFFFFF" height="1" bordercolor="#003399">
                        <tr>
            <td width="100%" bgcolor="#CAD6EE" style="border-left-color: #003399; border-left-width: 2; border-right-color: #003399; border-right-width: 2; border-top-color:#003399; border-bottom-color:#003399" height="20">
            <p style="margin: 2 3"><b>
            <font face="Verdana" size="2" color="#003399">Readings</font></b></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-bottom-style: none; border-bottom-width: medium; border-top-style:solid; border-top-width:1" height="25">
            <p style="margin: 2 3; "><a class="leftmenu" href="Chapter01.html">Chapter 1</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter02.html">Chapter 2</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter03.html">Chapter 3</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter04.html">Chapter 4</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter05.html">Chapter 5</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter06.html">Chapter 6</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter07.html">Chapter 7</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter08.html">Chapter 8</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter10.html">Chapter 10</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter11.html">Chapter 11</a></p></td>
                        </tr>                        
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter13.html">Chapter 13</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter14.html">Chapter 14</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter16.html">Chapter 16</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter17.html">Chapter 17</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter19.html">Chapter 19</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter20.html">Chapter 20</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter21.html">Chapter 21</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter22.html">Chapter 22</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter23.html">Chapter 23</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter24.html">Chapter 24</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter25.html">Chapter 25</a></p></td>
                        </tr>
                      </table>
                      </center>
                    </div>
                    </td>                    
                    <td width="855" style="border-left-style: none; border-left-width: medium; border-right-style: solid; border-right-width: 1; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium" height="1" valign="top">
                    <div style="margin-left:10px;margin-top:10px;margin-bottom:10px;margin-right:10px">
                    <h1>Chapter 14 - Building Multithreaded Applications</h1>
                    <span id="top" class="style1">Content</span>
                    <ul>
                    <li><a href="#rel" class="leftmenu">The Process/AppDomain/Context/Thread relationship</a></li>                    
                    <li><a href="#nam" class="leftmenu">The System.Threading namespace</a></li>
                    <li><a href="#cla" class="leftmenu">The System.Threading.Thread class</a></li>
                    <li><a href="#lif" class="leftmenu">Lifecycle of a Thread</a></li>
                    <li><a href="#thr" class="leftmenu">Programming creating Secondary threads</a></li>                    
                    <li><a href="#con" class="leftmenu">The issue of concurrency</a></li>
                    <li><a href="#tim" class="leftmenu">Programming with Timer Callbacks</a></li>                    
                    <li><a href="#poo" class="leftmenu">Understanding the CLR ThreadPool</a></li>                    
                    <li><a href="#sum" class="leftmenu">Summary</a></li>
                    </ul>
                    <p class="normal">
                    This chapter builds on your newfound knowledge by examining how the .NET platform allows you to build multithreaded applications and how to keep shared resources thread-safe.<br />                    
                    </p>
                    <span id="rel" class="style1">The Process/AppDomain/Context/Thread relationship</span>
                    <p class="normal">
                    The System.Threading namespace contains various types that allow you to create multithreaded applications. 
                    The Thread class is perhaps the core type, as it represents a given thread. If you wish to programmatically obtain a reference to the thread currently executing a given member, 
                    simply call the static Thread.CurrentThread property.<br />
                    Under the .NET platform, there is not a direct one-to-one correspondence between application domains and threads. 
                    In fact, a given AppDomain can have numerous threads executing within it at any given time. 
                    Furthermore, a particular thread is not confined to a single application domain during its lifetime. 
                    Threads are free to cross application domain boundaries as the Win32 thread scheduler and CLR see fit.<br />
                    Although active threads can be moved between AppDomain boundaries, a given thread can execute within only a single application domain at any point in time 
                    (in other words, it is impossible for a single thread to be doing work in more than one AppDomain). 
                    When you wish to programmatically gain access to the AppDomain that is hosting the current thread, call the static Thread.GetDomain()method.<br />
                    A single thread may also be moved into a particular context at any given time, and it may be relocated within a new context at the whim of the CLR. 
                    When you wish to obtain the current context a thread happens to be executing in, make use of the static Thread.CurrentContext property.<br />
                    Again, the CLR is the entity that is in charge of moving threads into (and out of ) application domains and contexts. 
                    As a .NET developer, you can usually remain blissfully unaware where a given thread ends up (or exactly when it is placed into its new boundary). 
                    Nevertheless, you should be aware of the various ways of obtaining the underlying primitives.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="nam" class="style1">The System.Threading namespace</span>
                    <p class="normal">
                    The System.Threading namespace provides a number of types that enable the construction of multithreaded applications. In addition to providing types that allow you to interact with a particular CLR thread, 
                    this namespace defines types that allow access to the CLR maintained thread pool, a simple (non–GUI-based) Timer class, and numerous types used to provide synchronized access to shared resources. 
                    The below table lists some of the core members of this namespace.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header">Type</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">Interlocked</td>
                            <td>This type provides atomic operations for types that are shared by multiple threads.</td>
                        </tr>
                        <tr>
                            <td valign="top">Monitor</td>
                            <td>This type provides the synchronization of threading objects using locks and wait/signals. 
                            The C# lock keyword makes use of a Monitor type under the hood.</td>
                        </tr>
                        <tr>
                            <td valign="top">Mutex</td>
                            <td>This synchronization primitive can be used for synchronization between application domain boundaries.</td>
                        </tr>
                        <tr>
                            <td valign="top">ParameterizedThreadStart</td>
                            <td>This delegate allows a thread to call methods that take any number of arguments.</td>
                        </tr>
                        <tr>
                            <td valign="top">Semaphore</td>
                            <td>This type allows you to limit the number of threads that can access a resource, or a particular type of resource, concurrently.</td>
                        </tr>
                        <tr>
                            <td valign="top">Thread</td>
                            <td>This type represents a thread that executes within the CLR. Using this type, you are able to spawn additional threads in the originating AppDomain.</td>
                        </tr>
                        <tr>
                            <td valign="top">ThreadPool</td>
                            <td>This type allows you to interact with the CLR-maintained thread pool within a given process.</td>
                        </tr>
                        <tr>
                            <td valign="top">ThreadPriority</td>
                            <td>This enum represents a thread’s priority level.</td>
                        </tr>
                        <tr>
                            <td valign="top">ThreadStart</td>
                            <td>This delegate is used to specify the method to call for a given thread. Unlike the ParameterizedThreadStart delegate, 
                            targets of ThreadStartmust match a fixed prototype.</td>
                        </tr>
                        <tr>
                            <td valign="top">ThreadState</td>
                            <td>This enum specifies the valid states a thread may take.</td>
                        </tr>
                        <tr>
                            <td valign="top">Timer</td>
                            <td>This type provides amechanism for executing amethod at specified intervals. </td>
                        </tr>
                        <tr>
                            <td valign="top">Timer Callback</td>
                            <td>This delegate type is used in conjunction with Timer types.</td>
                        </tr>
                    </table><br />
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="cla" class="style1">The System.Threading.Thread class</span>
                    <p class="normal">
                    The most primitive of all types in the System.Threading namespace is Thread. This class represents an object-oriented wrapper around a given path of execution within a particular AppDomain. 
                    This type also defines a number of methods (both static and shared) that allow you to create new threads within the current AppDomain, as well as to suspend, stop, and destroy a particular thread.<br />
                    The Thread class supports a property called Name. If you do not set this value, Name will return an empty string. However, once you assign a friendly string moniker to a given Thread object, you can greatly simplify your debugging endeavors.<br />
                    Next, notice that the Thread type defines a property named Priority. By default, all threads have a priority level of Normal. However, you can change this at any point in the thread's lifetime using the ThreadPriority property and the related System.Threading.ThreadPriority enumeration:<br />
                    <span class="sample">
                    <span class="keyword">public enum</span> ThreadPriority<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AboveNormal,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BelowNormal,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Highest,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Idle,<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Lowest,<br />                    
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Normal,<span class="comment">//Default value.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;TimeCritical<br />
                    }<br />
                    If you were to assign a thread's priority level to a value other than the default (ThreadPriority.Normal), understand that you would have little control over when the thread scheduler switches between threads. 
                    In reality, a thread's priority level offers a hint to the CLR regarding the importance of the thread's activity. Thus, a thread with the value ThreadPriority.Highest is not necessarily guaranteed to given the highest precedence.<br />
                    Again, if the thread scheduler is preoccupied with a given task (e.g., synchronizing an object, switching threads, or moving threads), the priority level will most likely be altered accordingly. 
                    However, all things being equal, the CLR will read these values and instruct the thread scheduler how to best allocate time slices. All things still being equal, threads with an identical thread priority should each receive the same amount of time to perform their work.                    
                    </span>
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="lif" class="style1">Lifecycle of a Thread</span><br /><br />
                    <div style="text-align:center;"><img alt="" src="images/1401.jpg" /></div><br />                    
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="thr" class="style1">Programmatically creating Secondary threades</span>
                    <p class="normal">
                    When you wish to programmatically create additional threads to carry on some unit of work, you will follow a very predictable process:
                    </p>
                    <ol>
                    <li>Create a type method to be the entry point for the new thread.</li>
                    <li>Create a new ParameterizedThreadStart (or legacy ThreadStart) delegate, passing the address of the method defined in step 1 to the constructor.</li>
                    <li>Create a Thread object, passing the ParameterizedThreadStart/ThreadStart delegate as a constructor argument.</li>
                    <li>Establish any initial thread characteristics (name, priority, etc.).</li>
                    <li>Call the Thread.Start()method. This starts the thread at the method referenced by the delegate created in step 2 as soon as possible.</li>
                    </ol>
                    <p class="normal">
                    As stated in step 2, you may make use of two distinct delegate types to "point to" the method that the secondary thread will execute. The ThreadStart delegate has been part of the System.Threading namespace since .NET 1.0, 
                    and it can point to any method that takes <i>no arguments</i> and returns <i>nothing</i>. This delegate can be helpful when the method is designed to simply run in the background without further interaction.<br />
                    The obvious limitation of ThreadStart is that you are unable to pass in parameters for processing. As of .NET 2.0, you are provided with the ParameterizedThreadStart delegate type, 
                    which allows a <i>single parameter</i> of type System.Object. Given that anything can be represented as a System.Object, you can pass in any number of parameters via a custom class or structure. 
                    Do note, however, that the ParameterizedThreadStart delegate can only point to methods that return <i>void</i>.
                    </p>
                    <p class="normal">
                    Reads example of working with the ThreadStart delegate at page 463, 464 of textbook.<br />
                    Reads example of working with the ParameterizedThreadStart delegate at page 465, 466 of textbook.<br />                    
                    </p>
                    <span class="style2">Foreground threads and Background threads</span><br />
                    <p class="normal">
                    <i>Foreground threads</i> have the ability to prevent the current application from terminating. The CLR will not shut down an application (which is to say, unload the hosting AppDomain) until all foreground threads have ended.<br />
                    <i>Background threads</i> (sometimes called <i>daemon threads</i>) are viewed by the CLR as expendable paths of execution that can be ignored at any point in time (even if they are currently laboring over some unit of work). 
                    Thus, if all foreground threads have terminated, any and all background threads are automatically killed when the application domain unloads.<br />
                    It is important to note that foreground and background threads are not synonymous with primary and worker threads. By default, every thread you create via the Thread.Start()method is automatically a <i>foreground thread</i>. 
                    Again, this means that the AppDomain will not unload until all threads of execution have completed their units of work. In most cases, this is exactly the behavior you require.<br />
                    For the most part, configuring a thread to run as a background type can be helpful when the worker thread in question is performing a noncritical task that is no longer needed when the main task of the program is finished.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>                    
                    <span id="con" class="style1">The issue of concurrency</span>
                    <p class="normal">
                    While some of your applications may be this simplistic in nature, a good deal of your multithreaded applications may contain numerous secondary threads. Given that all threads in an AppDomain have concurrent access to the shared data of the application, 
                    imagine what might happen if multiple threads were accessing the same point of data. As the thread scheduler will force threads to suspend their work at random, what if thread A is kicked out of the way before it has fully completed its work? 
                    Thread B is now reading unstable data.<br />
                    What we need is a way to programmatically enforce synchronized access to the shared resources. As you would guess, the System.Threading namespace provides a number of synchronization-centric types. 
                    The C# programming language also provides a particular keyword for the very task of synchronizing shared data in multithreaded applications.
                    </p>
                    <span class="style2">Synchronization using the C# lock keyword</span>
                    <p class="normal">
                    The first technique you can use to synchronize access to shared resources is the C# lock keyword. This keyword allows you to define a scope of statements that must be synchronized between threads. By doing so, incoming threads cannot interrupt the current thread, 
                    preventing it from finishing its work. The lock keyword requires you to specify a <i>token</i> (an object reference) that must be acquired by a thread to enter within the lock scope.When you are attempting to lock down an instance-level method, you can simply pass in a reference to the current type:<br />
                    <span class="sample">
                    <span class="comment">//Use the current object as the thread token.</span><br />
                    <span class="keyword">lock</span>(<span class="keyword">this</span>)<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//All code within this scope is thread-safe.</span><br />
                    }
                    </span>
                    </p>
                    <span class="style2">Synchronization using the System.Threading.Monitor type</span>
                    <p class="normal">
                    The C# lock statement is really just a shorthand notation for working with the System.Threading.Monitor class type. Once processed by the C# compiler, a lock scope actually resolves to the following:
                    </p>
                    <p class="sample">
                    <span class="keyword">public void</span> PrintNumbers()<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monitor.Enter(<span class="keyword">this</span>);<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">try</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Do something.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">finally</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monitor.Exit(<span class="keyword">this</span>);<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    }
                    </p>
                    <p class="normal">
                    First, notice that the Monitor.Enter()method is the ultimate recipient of the thread token you specified as the argument to the lock keyword. 
                    Next, all code within a lock scope is wrapped within a try block. The corresponding finally clause ensures that the thread token is released 
                    (via the Monitor.Exit() method), regardless of any possible runtime exception.<br />
                    Now, given that the lock keyword seems to require less code than making explicit use of the System.Threading.Monitor type, you may wonder about the benefits of using the Monitor type directly. 
                    The short answer is control. If you make use of the Monitor type, you are able to instruct the active thread to wait for some duration of time (via the Wait()method), inform waiting threads 
                    when the current thread is completed (via the Pulse() and PulseAll()methods), and so on.
                    </p>
                    <span class="style2">Synchronization using the System.Threading.Interlocked type</span>
                    <p class="normal">
                    Although it always is hard to believe until you look at the underlying CIL code, assignments and simple arithmetic operations are <i>not atomic</i>. 
                    For this reason, the System.Threading namespace provides a type that allows you to operate on a single point of data atomically with less overhead than with the Monitor type. 
                    The Interlocked class type defines the static members shown in the below table.
                    </p>
                    <table border="1" cellpadding="5" cellspacing="0">
                        <tr>
                            <td class="header">Member</td>
                            <td class="header">Meaning in Life</td>
                        </tr>
                        <tr>
                            <td valign="top">CompareExchange()</td>
                            <td>Safely tests two values for equality and, if equal, changes one of the values with a third.</td>
                        </tr>
                        <tr>
                            <td valign="top">Decrement()</td>
                            <td>Safely decrements a value by 1.</td>
                        </tr>
                        <tr>
                            <td valign="top">Exchange()</td>
                            <td>Safely swaps two values.</td>
                        </tr>
                        <tr>
                            <td>Increment()</td>
                            <td>Safely increments a value by 1</td>
                        </tr>
                    </table><br />
                    <span class="style2">Synchronization using the [Synchronization] attribute</span>
                    <p class="normal">
                    The final synchronization primitive examined here is the [Synchronization] attribute, which is a member of the System.Runtime.Remoting.Contexts namespace. 
                    In essence, this class-level attribute effectively locks down <i>all</i> instance member code of the object for thread safety. 
                    When the CLR allocates objects attributed with [Synchronization], it will place the object within a synchronized context. 
                    As you may recall from Chapter 13, objects that should not be removed from a contextual boundary should derive from ContextBoundObject.<br />
                    In some ways, this approach can be seen as the lazy way to write thread-safe code, given that you are not required to dive into the details about which aspects of the type are truly manipulating thread-sensitive data. 
                    The major downfall of this approach, however, is that even if a given method is not making use of thread-sensitive data, the CLR will still lock invocations to the method. Obviously, this could degrade the overall functionality of the type, 
                    so use this technique with care.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="tim" class="style1">Programming with Timer Callbacks</span>
                    <p class="normal">
                    Many applications have the need to call a specific method during regular intervals of time. For example, you may have an application that needs to display the current time on a status bar via a given helper function. 
                    As another example, you may wish to have your application call a helper function every so often to perform noncritical background tasks such as checking for new e-mail messages. 
                    For situations such as these, you can use the System.Threading.Timer type in conjunction with a related delegate named TimerCallback.<br />
                    Reads example of printing the current time every second until the user presses a key to terminate the application at page 473, 474 of textbook.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>                    
                    <span id="poo" class="style1">Understanding the CLR ThreadPool</span>
                    <p class="normal">
                    The final thread-centric topic we will examine in this chapter is the CLR thread pool. When you invoke a method asynchronously using delegate types (via the BeginInvoke()method), 
                    the CLR does not literally create a brand-new thread. For purposes of efficiency, a delegate's BeginInvoke() method leverages a pool of worker threads that is maintained by the runtime. 
                    To allow you to interact with this pool of waiting threads, the System.Threading namespace provides the ThreadPool class type.<br />
                    If you wish to queue amethod call for processing by a worker thread in the pool, you can make use of the ThreadPool.QueueUserWorkItem()method. 
                    This method has been overloaded to allow you to specify an optional System.Object for custom state data in addition to an instance of the WaitCallback delegate.<br />
                    The WaitCallback delegate can point to any method that takes a System.Object as its sole parameter (which represents the optional state data) and returns nothing. 
                    Do note that if you do not provide a System.Object when calling QueueUserWorkItem(), the CLR automatically passes a null value.<br />
                    At this point, you may be wondering if it would be advantageous to make use of the CLR maintained thread pool rather than explicitly creating Thread objects. 
                    Consider these major benefits of leveraging the thread pool:
                    </p>
                    <ul>
                    <li>The thread pool manages threads efficiently by minimizing the number of threads that must be created, started, and stopped.</li>
                    <li>By using the thread pool, you can focus on your business problem rather than the application's threading infrastructure</li>
                    </ul>
                    <p class="normal">However, using manual thread management is preferred in some cases, for example:</p>
                    <ul>
                    <li>If you require foreground threads or must set the thread priority. Pooled threads are always background threads with default priority (ThreadPriority.Normal).</li>
                    <li>If you require a thread with a fixed identity in order to abort it, suspend it, or discover it by name.</li>
                    </ul>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>                    
                    <span id="sum" class="style1">Summary</span>
                    <p class="normal">
                    The main of this chapter examined the role of the System.Threading namespace. When an application creates additional threads of execution, 
                    the result is that the program in question is able to carry out numerous tasks at (what appears to be) the same time. 
                    You also examined several manners in which you can protect thread-sensitive blocks of code to ensure that shared resources do not become unusable units of bogus data. 
                    Last but not least, you learned that the CLR maintains an internal pool of threads for the purposes of performance and convenience.
                    </p>
                    </div>
                    </td>
                  </tr>
                </table>
                </td>
              </tr>
            </table>
            </td>
          </tr>
          <tr>
            <td width="100%" style="border-bottom:1px solid #006666; border-left:1px solid #006666; border-right:1px solid #006666; border-top-style: none; border-top-width: medium; " align="center" colspan="5" bgcolor="#006666" height="1">
            <p style="margin-top: 3; margin-bottom: 3"><b>
            <font face="Verdana" size="1" color="#FFFFFF">Copyright 2010
             All Rights Reserved.
             </font></b></p></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>    
      </center>
    </div>    
</body>
</html>