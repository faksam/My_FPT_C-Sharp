<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252" />
<title>FPT University - C# & .NET technology</title>
<link rel="stylesheet" href="cf112.css" type="text/css" charset="utf-8" />
</head>
<body>
    <div align="center">
      <center>
    <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0; bordercolor: #111111" width="1024" id="AutoNumber6">
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; height:168px" height="2" bgcolor="#339966" bordercolor="#333333" background="images/background.jpg"><br /><br />
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0; text-align:center" ><br/>
        <b><font size="5" color="#FFFFFF" face="Arial Black">Software Development</font></b></p>
        <p style="margin-left: 4; margin-top: 0; margin-bottom: 0"><i>
        <font face="Arial Black" color="#FFCC00">&nbsp;</font></i><br/>
        <br/></p>&nbsp;</td>
      </tr>
      <tr>
        <td width="1024" style="border-style: none; border-width: medium; bordercolor:#333333" bgcolor="#FFFFFF" valign="top">
        <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 0; border-right-width: 0; border-bottom-width:0" bordercolor="#006666" width="100%" id="AutoNumber7" height="8">
          <tr>
            <td width="12%" style="border-left: 1px solid #006666; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="index.html">Home</a></td>
            <td width="18%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="outline.html">Outline</a></td>
            <td width="26%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="timeline.html">Timeline</a></td>
            <td width="24%" style="border-left-style: solid; border-left-width: 1; border-right-style: solid; border-right-width: 1; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="readings.html">Readings</a></td>
            <td width="20%" style="border-left-style: solid; border-left-width: 1; border-right: 1px solid #006666; border-top-style: solid; border-top-width: 1; border-bottom-style:none; border-bottom-width:medium" align="center" bgcolor="#006666" bordercolor="#339966" height="15">
            <a class="mainmenu" href="instructors.html">Instructors</a></td>
          </tr>
          <tr>
            <td width="100%" style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: solid; border-top-width: 1; border-bottom-style: none; border-bottom-width: medium" align="center" colspan="5">
            <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-width: 0" bordercolor="#111111" width="100%" id="AutoNumber8">
              <tr>
                <td width="100%" style="border-style: none; border-width: medium">
                <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse; border-left-width: 2; border-right-width: 2; border-top-width: 2; border-bottom-width: 0" bordercolor="#006666" id="AutoNumber9" height="1">
                  <tr>
                    <td width="100%" style="border-style: none; border-width: medium" height="1" colspan="2" bgcolor="#004646">
                    <p style="margin-top: -6; margin-bottom: -6"/></td>
                  </tr>
                  <tr>
                    <td style="border-left-style: none; border-left-width: medium; border-right-style: none; border-right-width: medium; border-top-style: none; border-top-width: medium; border-bottom: 2px none #006666" height="1" bgcolor="#006666" valign="top">
                    <div align="center" style="width: 169">
                      <center>
                      <p style="margin-top: -4; margin-bottom: -4">&nbsp;</p>
                      <table border="1" cellpadding="0" cellspacing="0" style="border-collapse: collapse" width="91%" id="AutoNumber10" bgcolor="#FFFFFF" height="1" bordercolor="#003399">
                        <tr>
            <td width="100%" bgcolor="#CAD6EE" style="border-left-color: #003399; border-left-width: 2; border-right-color: #003399; border-right-width: 2; border-top-color:#003399; border-bottom-color:#003399" height="20">
            <p style="margin: 2 3"><b>
            <font face="Verdana" size="2" color="#003399">Readings</font></b></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-bottom-style: none; border-bottom-width: medium; border-top-style:solid; border-top-width:1" height="25">
            <p style="margin: 2 3; "><a class="leftmenu" href="Chapter01.html">Chapter 1</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter02.html">Chapter 2</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter03.html">Chapter 3</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter04.html">Chapter 4</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter05.html">Chapter 5</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium; " height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter06.html">Chapter 6</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter07.html">Chapter 7</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter08.html">Chapter 8</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter10.html">Chapter 10</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter11.html">Chapter 11</a></p></td>
                        </tr>                        
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter13.html">Chapter 13</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter14.html">Chapter 14</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter16.html">Chapter 16</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter17.html">Chapter 17</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter19.html">Chapter 19</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter20.html">Chapter 20</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter21.html">Chapter 21</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter22.html">Chapter 22</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter23.html">Chapter 23</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter24.html">Chapter 24</a></p></td>
                        </tr>
                        <tr>
            <td width="100%" bgcolor="#FFFFFF" style="border-left:1px solid #FF0000; border-right:1px solid #FF0000; border-top-style: none; border-top-width: medium; border-bottom-style:solid; border-bottom-width:1" height="25">
            <p style="margin: 2 3"><a class="leftmenu" href="Chapter25.html">Chapter 25</a></p></td>
                        </tr>
                      </table>
                      </center>
                    </div>
                    </td>                    
                    <td width="855" style="border-left-style: none; border-left-width: medium; border-right-style: solid; border-right-width: 1; border-top-style: none; border-top-width: medium; border-bottom-style: none; border-bottom-width: medium" height="1" valign="top">
                    <div style="margin-left:10px;margin-top:10px;margin-bottom:10px;margin-right:10px">
                    <h1>Chapter 4 - Object Oriented Programming with C#</h1>
                    <span id="top" class="style1">Content</span>
                    <ul>
                    <li><a href="#oop" class="leftmenu">Reviewing the pillars of OOP</a></li>                    
                    <li><a href="#cla" class="leftmenu">The C# class type</a></li>
                    <li><a href="#enc" class="leftmenu">C#'s encapsulation services</a></li>
                    <li><a href="#inh" class="leftmenu">C#'s inheritance and polymorphic support</a></li>                    
                    <li><a href="#cas" class="leftmenu">C# casting rules</a></li>
                    <li><a href="#par" class="leftmenu">C# partial types</a></li>
                    <li><a href="#sum" class="leftmenu">Summary</a></li>
                    </ul>
                    <p class="normal">
                    The chapter begins with a review of the famed "pillars of OOP" and then examines exactly how C# contends with the notions of 
                    encapsulation, inheritance and polymorphism.<br />
                    During this process, you examine some new constructs such as type properties, versioning type members and "sealed" classes.                    
                    </p>
                    <span id="oop" class="style1">Reviewing the pillars of OOP</span>
                    <p class="normal">
                    All object-oriented languages contend with three core principles of object-oriented programming, often called the famed "pillars of OOP".
                    </p>
                    <ul>
                    <li><i>Encapsulation</i>: How does this language hide an object's internal implementation?</li>
                    <li><i>Inheritance</i>: How does this language promote code reuse?</li>
                    <li><i>Polymorphism</i>: How does this language let you treat related objects in a similar way?</li>
                    </ul>
                    <p class="normal">
                    Encapsulation boils down to the language's ability to hide unnecessary implementation details from the object user. 
                    Another aspect of encapsulation is the notion of data protection. Ideally, an object's state data should be defined as <i>private</i> rather than <i>public</i>.<br />
                    Inheritance boils down to the language's ability to allow you to build new class definitions based on existing class definitions. 
                    In essence, inheritance allows you to extend the behavior of a base (or <i>parent</i>) class by enabling a subclass to inherit core functionality 
                    (also called a <i>derived class</i> or <i>child class</i>).<br />
                    There is another form of code reuse in the world of OOP: the containment/delegation model (also known as the "has-a" relationship). 
                    This form of reuse is not used to establish base/subclass relationships. Rather, a given class can define a member variable of another class and 
                    expose part or all of its functionality to the outside world.<br />
                    Polymorphism captures a language's ability to treat related objects the same way. This tend of object-oriented language allows a base class to define a set of members 
                    (formally termed the <i>polymorphic interface</i>) to all descendents. A class type's polymorphic interface is constructed using any number of <i>virtual</i> or <i>abstract</i> members. 
                    In a nutshell, a virtual member may be changed (or more formally speaking, <i>overridden</i>) by a derived class, whereas an abstract method <i>must</i> be overridden by a derived type. 
                    When derived types override the members defined by a base class, they are essentially redefining how they respond to the same request.                    
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="cla" class="style1">The C# class type</span>
                    <p class="normal">
                    Formally, a class is a custom user-defined type (UDT) that is composed of field data (sometimes termed <i>member variables</i>) and functions (often called <i>methods</i> in OO speak) that acts on this data. 
                    The set of field data collectively represents the "state" of a class instance.<br />
                    C# classes can define any number of <i>constructors</i>. These special class methods provide a simple way for an object user to create an instance of a given class with an initial look and feel. 
                    Every C# class is initially provided with a <i>default constructor</i>, which by definition never take arguments. In addition to default constructor, you are also free to define as many custom 
                    constructors as you feel are necessary.                    
                    </p>
                    <span class="style2">Understanding method overloading</span>
                    <p class="normal">
                    C# allows a type to <i>overload</i> various methods. When a class has a set of identically named members that differ by the number (or type) of parameters, 
                    the member in question is said to be <i>overloaded</i>.
                    </p>
                    <span class="style2">Self-Reference in C# using this</span>
                    <p class="normal">
                    C# <i>this</i> keyword is used when you wish to explicitly reference the fields and members of the <i>current object</i>. 
                    The reason you made use of this in your custom constructor was to avoid clashes between the parameter names and names of your internal state variables.<br />
                    Another use of this keyword is to force one constructor to call another in order to avoid redundant member initialization logic. For example:
                    </p>
                    <p class="sample">
                    <span class="keyword">public class</span> Employee<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> Employee(<span class="keyword">string</span> fullName, <span class="keyword">int</span> empID, <span class="keyword">float</span> currPay)<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.fullName = fullName;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.empID = empID;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.currPay = currPay;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//If the user calls this ctor, forward to the 3-arg version.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span> Employee(<span class="keyword">string</span> fullName)<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="keyword">this</span>(fullName, IDGenerator.GetNewEmpID(), 0.0f) {}<br />}
                    </p>
                    <p class="normal">
                    If you did not forward the call, you would need to add redundant code to each constructor:
                    </p>
                    <p class="sample">
                    <span class="comment">//currPay automatically set to 0.0f via default values</span><br />
                    <span class="keyword">public</span> Employee(<span class="keyword">string</span> fullName)<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.fullName = fullName;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">this</span>.empID = IDGenerator.GetNewEmpID();<br />
                    }<br />
                    </p>
                    <p class="normal">
                    Understand that using the this keyword to forward constructor calls is not mandatory. However, when you make use of this technique, 
                    you do tend to end up with a more maintainable and concise class definition. In fact, using this technique you can simplify your programming tasks, 
                    as the real work is delegated to a single constructor (typically the constructor that has the most parameters), 
                    while the other constructors simply "pass the buck".
                    </p>
                    <span class="style2">Defining the Public Interface of a class</span>
                    <p class="normal">
                    Public interface is a term refers to the set of members that are directly accessible from an object variable via the dot operator.<br />
                    From the class builder's point of view, the public interface is any item declared in a class using the public keyword. Beyond field data and 
                    constructors, the public interface of a class may be populated by numerous members, include the following:
                    </p>
                    <ul>
                    <li><i>Methods</i>: Named units of work that model some behavior of a class.</li>
                    <li><i>Properties</i>: Traditional accessor and mutator functions in disguise.</li>
                    <li><i>Constants/Read-only fields</i>: Field data that cannot be changed after assignment.</li>
                    </ul>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="enc" class="style1">C#'s encapsulation services</span>
                    <p class="normal">
                    The concept of encapsulation revolves around the notion that an object's field data should not be directly accessible from the public interface. 
                    Rather, if an object user wishes to alter the state of an object, it does so indirectly using accessor (get) and mutator (set) methods. 
                    In C#, encasulation is enforced at the syntactic level using the public, private, protected, and protected internal keywords.<br />
                    Encapsulation provides a way to preserve the integrity of state data. Rather than defining public fields (which can easily foster data corruption), 
                    you should get in the habit of defining <i>private data fields</i>, which are indirectly manipulated by the caller using one of two main techniques:
                    </p>
                    <ul>
                    <li>Define a pair of traditional accessor and mutator methods.</li>
                    <li>Define a named property.</li>
                    </ul>
                    <p class="normal">
                    Whichever technique you choose, the point is that a well-encapsulated class should hide its raw data and the details of how it operates from the prying eyes of the outside worlds. 
                    This if oftern termed <i>black box programming</i>. The beauty of this approach is that a class author is free to change how a given method is implemented under the hood, 
                    without breaking any existing code making use of it.<br />
                    Read example about enforcing encapsulation using traditional accessors and mutators at page 148 of textbook.<br />
                    In contract to traditional accessor and mutator methods, .NET languages prefer to enforce encapsulation using <i>properties</i>, 
                    which simulate publicly accessible points of data. Rather than requiring the user to call two different methods to get and set the state data, 
                    the user is able to call what appears to be a public field.<br />
                    To illustrate, assume you have provided a property named ID that wraps the internal empID member variable of the Employee type. 
                    The calling syntax would look like this:                    
                    </p>
                    <p class="sample">
                    <span class="comment">//Setting / getting a person's ID through property syntax.</span><br />
                    <span class="keyword">static void</span> Main(<span class="keyword">string</span>[] args)<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Employee p = <span class="keyword">new</span> Employee();<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Set the value.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p.ID = 81;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Get the value.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.WriteLine("Person ID is: {0}", p.ID);<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Console.ReadLine();<br />}
                    </p>
                    <p class="normal">
                    Type properties always map to "real" accessor and mutator methods under the hood. Therefore, as a class designer, you are able to perform any internal logic necessary before 
                    making the value assignment. Here is syntax behind the ID property of the Employee type.
                    </p>
                    <p class="sample">
                    <span class="comment">//Encapsulation with properties.</span><br />
                    <span class="keyword">public class</span> Employee<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private int</span> empID;<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//Property for empID.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public int</span> ID<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">get</span> { return empID;}<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">set</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//You are still free to investigate (and possibly transform)</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//the incoming value before making an assignment.</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;empID = <span class="keyword">value;</span><br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br />
                    }<br />
                    </p>
                    <p class="normal">
                    A C# property is composed using a get block (accessor) and set block (mutator). The C# "value" token represents the right-hand side of the assignment. 
                    The underlying data type of the value token depends on which sort of data it represents.<br />
                    As opposed to traditional accessors and mutators, properties also make your types easier to manipulate, in that properties are able to respond to the intrinsic operator of C#.<br />
                    A C# property is represented in CIL code using "get_" and "set_" prefixes.<br />
                    Types of property:
                    </p>
                    <ul>
                    <li>Read/write properties, have both get and set blocks.</li>
                    <li>Read-only properties, have get block only. Note that read-only properties are not constants.</li>
                    <li>Write-only properties, have set block only.</li>
                    <li>Static properties, are accessed at the class level, not from an instance of that class.</li>
                    </ul>
                    <p class="normal">
                    To wrap up our examination of encapsulation, understand that properties are used for the same purpose as a classical accessor/mutator pair. 
                    The benefit of properties is that the users of your objects are able to manipulate the internal data point using a single named item.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="inh" class="style1">C#'s inheritance and polymorphic support</span>
                    <p class="normal">
                    Inheritance is the aspect of OOP that facilitates code reuse. Inheritance comes in two flavors: classical inheritance (the "is-a" relationship) 
                    and the containtement/delegation model (the "has-a" relationship).<br />
                    When you establish "is-a" relationship between classes, you are building a dependency between types. 
                    The basic idea behind classical inheritance is that new classes may leverage (and possible extend) the functionality of other classes. 
                    In C#, extending a class is accomplished using the colon operator (:) on the class definition. For example, the statement 
                    <span class="sample"><span class="keyword">public class</span> Manager : Employee</span> defines a Manager class that extends Employee class.<br />
                    Do be ware that inheritance preserves encapsulation. Therefore, a derived class cannot directly access the private members defined by its base class.<br />
                    </p>
                    <span class="style2">Controlling base class creation with base</span>
                    <p class="normal">In C#, unless you say otherwise, the <i>defalut constructor</i> of a base class is called automatically before the logic of the custom derived class constructor. 
                    To help optimize the creation of a derived class, you will do well to implement your subclass constructor to <i>explicitly</i> call an appropriate custome base class constructor, 
                    rather than the default. In this way, you are able to reduce the number of calls to inherited initialization members (which saves time). For example,</p>
                    <p class="sample">
                    <span class="comment">//Use the C# "base keyword to call a custom constructor on the base class"</span><br />
                    <span class="keyword">public</span> Manager(<span class="keyword">string</span> fullName, <span class="keyword">int</span> age, <span class="keyword">int</span> empID, <span class="keyword">float</span> currPay, <span class="keyword">string</span> ssn, <span class="keyword">ulong</span> numbOfOpts)<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: <span class="keyword">base</span>(fullName, age, empID, currPay, ssn)<br />
                    {<br />
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;numberOfOptions = numbOfOpts;
                    <br />}
                    </p>
                    <p class="normal">
                    Speaking of base classes, it is important to keep in mind that C# demands that a given class have <i>exactly one</i> direct base class. 
                    Therefore, it is not possible to have a single type with two or more base classes (this technique is known as <i>multiple inheritance</i>).
                    </p>
                    <span class="style2">Preventing inheritance: Sealed classes</span>
                    <p class="normal">
                    To prevent other classes from extending a class, make use of the C# sealed keyword.<br />
                    Read examples about sealead classes at page 159 of textbook.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span class="style2">Override methods</span>
                    <p class="normal">
                    Override method is an instance method declaration includes an <i>override</i> operator.<br />
                    Overridden base method is a method overridden by an <i>override</i> declaration. Overridden base method is a virtual, abstract, or override method.<br />
                    Override and overridden base method have the same return type and declared accessiblity.<br />
                    <i>base</i> keyword is used to access the members of a base class from within a derived class, and 
                    to call constructors of a base class while creating an instance of a derived class. 
                    Note that use the base keyword in a static method will result in an error.<br />
                    <i>virtual</i> keyword is used in the definition of a method to support polymorphism. This keyword is used to modify method declaration in a class. 
                    Child classes are free to implement their own versions of virtual method using override keyword. 
                    Virtual modifier cannot used with modifiers like static and override.<br />
                    <i>override</i> keyword is used to modify a method. An override method provides a new implementation of the base method. 
                    The base method should be declared as virtual. Accessibility level of a base method cannot be changed by a method overriding it. 
                    Keyword new, static, virtual cannot be used along with override modifier.
                    <i>new</i> keyword is used as an operator or as a modifier. new modifier is used to explicitly hide a member that is inherited from the base class. 
                    It is an error to use both new and override on the same method.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="cas" class="style1">C# casting rules</span>
                    <p class="normal">
                    The first law of casting between class types is that when two classes are related by an "is-a" relationship, it is always safe to store a derived type within a base class reference. 
                    Formally, this is called as an <i>implicit cast</i>, as "it just works" given the law of inheritance.<br />
                    In C#, <i>explicit casts</i> are denoted by placing parentheses around the types you wish to cast to, followed by the object you are attempting to cast from.<br />
                    To wrap up out examination of C# casting operations, be aware that the numerical conversions follow more or less the same rules. 
                    If you are attempting to place a "larger" numerical type to a "smaller" type (such as an interger into a byte), you must also make an explicit cast that informs the compiler 
                    you are willing to accept any possible data loss.<br />
                    However, when you are storing a "smaller" numerical type into a "larger" type (such as a byte into an integer), the type is implicitly cast on your behalf, as there is no loss of data.
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="par" class="style1">C# partial types</span>
                    <p class="normal">
                    C# 2005 and later introduces a new type modifier named partial that allows you to define a C# type across multiple *.cs files. 
                    If a production-level C# class is hundreds of lines of code (or more), it would be ideal to partition a type's implementation across numerous C# files.                    
                    </p>
                    <div style="width:100%;text-align:right;"><a class="leftmenu" href="#top">Back to top</a></div>
                    <span id="sum" class="style1">Summary</span>
                    <p class="normal">
                    This chapter began with a review of the pillars of OOP: encapsulation, inheritance and polymorphism. 
                    Encapsulation services can be accounted for using traditional accessor/mutator methods, type properties, or read-only public fields. 
                    Inheritance under C# could not be any simpler, given that the language does not provide a specific keyword, but rather makes use of the simple colon operator. 
                    Last but not least, you have polymorphism, which is supported via the abstract, virtual, override and new keywords.
                    </p>
                    </div>
                    </td>
                  </tr>
                </table>
                </td>
              </tr>
            </table>
            </td>
          </tr>
          <tr>
            <td width="100%" style="border-bottom:1px solid #006666; border-left:1px solid #006666; border-right:1px solid #006666; border-top-style: none; border-top-width: medium; " align="center" colspan="5" bgcolor="#006666" height="1">
            <p style="margin-top: 3; margin-bottom: 3"><b>
            <font face="Verdana" size="1" color="#FFFFFF">Copyright 2010
             All Rights Reserved.
             </font></b></p></td>
          </tr>
        </table>
        </td>
      </tr>
    </table>    
      </center>
    </div>    
</body>
</html>